#### 专题一：直播课笔记

#### 自己查的资料
**单测**
1. 单元测试，首先要弄清楚什么是单元。单元就是一个相对独立的功能模块，可以是一个类、或是一个模块，或是一个方法。
单元测试的目的，就是首先保证一个系统的基本组成单元（类 模块 方法）能正常工作。打个比方，你想一台机器能正常工作，首先要保证它的每一个零件和组件能正常工作。而单元测试就是对这些零件和组件进行的测试。
2. 进行单测的必要性：
* 验证代码的正确性
* 避免修改代码时出错
* 避免其他团队成员修改代码时出错
* 便于自动化测试与部署

入门：https://blog.csdn.net/qq_25600055/article/details/79844284

廖雪峰：https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00147203593334596b366f3fe0b409fbc30ad81a0a91c4a000

**函数式编程**
https://www.cnblogs.com/tjyoung/p/8976013.html
看了这边文章，真心是不好理解，直播课内容和这边博客内容几乎一样~
1. 函数式编程(Functional Programming)

#### 3.19 函数式编程(functional programming)直播课
- 因react的高阶函数而火起来的
- 函数式编程不是用函数编程，是用数学的思维方式 借助js的语法，去编程，没有if else
- 柯里化，对函数参数的缓存   bind也是一种柯里化
- 浏览器目前没有实现尾调用优化
- console.trace() 可以查看调用帧
- 闭包 缓存了上下文执行环境的词法作用域(对值进行缓存)

**函数式编程思维**
**范畴论**：
1. 函数式编程是范畴论的数学分支是一门很复杂的数学，认为世界上所有概念体系都可以抽象出一个个范畴
2. 彼此之间存在某种关系概念、事物、对象等等，都构成范畴，任何事物只要找出他们之间的关系，就能定义
3. 箭头表示范畴成员之间的关系，正式的名称叫做“态射”(morphism),范畴论认为，同一个范畴的所有成员，就是不同状态的“变形”（Transformation），通过“态射”，一个成员可以变形成另一个成员。
所有成员是集合，变形关系是函数

**函数式编程常用核心概念**
* 纯函数，对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态的函数，叫做纯函数。
* 函数柯里化，传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。事实上柯里化是一种“**预加载**”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“**缓存**”，是一种非常高效的编写函数的方法。
* 函数组合，为了解决函数嵌套过深，洋葱代码：h(g(f(x))), 我们需要用到“函数组合”
* Point Free，把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。
* 声明式与命令式代码，在我们日常业务开发中，写的代码绝大多数都为命令式代码；我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。
* 惰性函数，https://juejin.im/post/591e3347570c3500698795e4
* 核心概念
1. **高阶函数，**就是把函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象。
2. **递归与尾递归**，指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数，函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了，通俗点说，尾递归最后一步需要调用自身，并且之后不能有其它额外操作。
**现在浏览器还没有实现尾递归调用优化**
console.trace() 查看调用帧
尾递归调用优化向while看齐

**函子**
函子也是容器，有个map之后才是函子（一般约定，函子的标志就是容器具有map方法）
就是数学的思想，一堆数通过映射关系变成另外一堆数
函数式编程一般约定，函子有一个Of方法，用来生成新的容器
* **Maybe函子**，函子接受各种函数，处理容器内部的值，这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。

**js and QA测试工程师**